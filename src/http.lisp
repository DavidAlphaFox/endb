(defpackage :endb/http
  (:use :cl)
  (:export #:make-api-handler)
  (:import-from :alexandria)
  (:import-from :bordeaux-threads)
  (:import-from :lack.request)
  (:import-from :cl-ppcre)
  (:import-from :com.inuoe.jzon)
  (:import-from :log4cl)
  (:import-from :trivial-utf-8)
  (:import-from :endb/lib/parser)
  (:import-from :endb/sql)
  (:import-from :endb/sql/expr)
  (:import-from :endb/storage/meta-data))
(in-package :endb/http)

(defconstant +http-ok+ 200)
(defconstant +http-created+ 201)
(defconstant +http-bad-request+ 400)
(defconstant +http-not-found+ 404)
(defconstant +http-method-not-allowed+ 405)
(defconstant +http-not-acceptable+ 406)
(defconstant +http-conflict+ 409)
(defconstant +http-unsupported-media-type+ 415)
(defconstant +http-internal-server-error+ 500)

(defparameter *crlf* (coerce '(#\return #\linefeed) 'string))
(defparameter *request-media-types* '("application/sql" "application/x-www-form-urlencoded" "multipart/"))
(defparameter *response-media-types* '("application/json" "application/x-ndjson" "application/ld+json" "text/csv"))

(defun %format-csv (x)
  (cl-ppcre:regex-replace-all "\\\\\"" (com.inuoe.jzon:stringify x) "\"\""))

(defun %empty-response (status &optional headers)
  (list status (append headers '(:content-type "text/plain" :content-length 0)) '("")))

(defun %stream-response (req status column-names rows)
  (lambda (responder)
    (let* ((content-type (cond
                           ((lack.request:request-accepts-p req "application/json")
                            "application/json")
                           ((lack.request:request-accepts-p req "application/ld+json")
                            "application/ld+json")
                           ((lack.request:request-accepts-p req "application/x-ndjson")
                            "application/x-ndjson")
                           ((lack.request:request-accepts-p req "text/csv")
                            "text/csv")))
           (writer (funcall responder (list status (list :content-type content-type)))))
      (cond
        ((equal "application/json" content-type)
         (progn (funcall writer "[")
                (loop for row in rows
                      for idx from 0
                      unless (zerop idx)
                        do (funcall writer ",")
                      do (funcall writer (com.inuoe.jzon:stringify row))
                      finally (funcall writer (format nil "]~%") :close t))))
        ((equal "application/ld+json" content-type)
         (let ((endb/storage/meta-data:*json-ld-scalars* t))
           (funcall writer "{\"@context\":{\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"@vocab\":\"http://endatabas.com/\"},\"@graph\":[")
           (loop for row in rows
                 for idx from 0
                 unless (zerop idx)
                   do (funcall writer ",")
                 do (funcall writer
                             (with-output-to-string (out)
                               (com.inuoe.jzon:with-writer (writer :stream out)
                                 (com.inuoe.jzon:with-object writer
                                   (loop for column in row
                                         for column-name in column-names
                                         do (com.inuoe.jzon:write-key writer column-name)
                                            (com.inuoe.jzon:write-value writer column))))))
                 finally (funcall writer (format nil "]}~%") :close t))))
        ((equal "application/x-ndjson" content-type)
         (loop for row in rows
               do (funcall writer
                           (with-output-to-string (out)
                             (com.inuoe.jzon:with-writer (writer :stream out)
                               (com.inuoe.jzon:with-object writer
                                 (loop for column in row
                                       for column-name in column-names
                                       do (com.inuoe.jzon:write-key writer column-name)
                                          (com.inuoe.jzon:write-value writer column))))
                             (write-char #\NewLine out)))
               finally (funcall writer nil :close t)))
        ((equal "text/csv" content-type)
         (loop for row in (cons column-names rows)
               do (funcall writer (format nil "~{~A~^,~}~A" (mapcar #'%format-csv row) *crlf*))
               finally (funcall writer nil :close t)))))))

(defun %error-response (status error)
  (list status '(:content-type "text/plain") (list (format nil "~A~%" error))))

(defun make-api-handler (db)
  (let ((write-lock (bt:make-lock)))
    (lambda (env)
      (handler-case
          (let ((req (lack.request:make-request env)))
            (log:debug req)
            (if (equal "/sql" (lack.request:request-path-info req))
                (if (member (lack.request:request-method req) '(:get :post))
                    (if (and (eq :post (lack.request:request-method req))
                             (notany (lambda (x)
                                       (alexandria:starts-with-subseq x (lack.request:request-content-type req)))
                                     *request-media-types*))
                        (%empty-response +http-unsupported-media-type+)
                        (let* ((write-db (endb/sql:begin-write-tx db))
                               (original-md (endb/sql/expr:db-meta-data write-db))
                               (sql (if (and (eq :post (lack.request:request-method req))
                                             (equal "application/sql" (lack.request:request-content-type req)))
                                        (trivial-utf-8:utf-8-bytes-to-string (lack.request:request-content req))
                                        (cdr (assoc "q" (lack.request:request-parameters req) :test 'equal)))))
                          (if sql
                              (if (some (lambda (media-type)
                                          (lack.request:request-accepts-p req media-type))
                                        *response-media-types*)
                                  (multiple-value-bind (result result-code)
                                      (endb/sql:execute-sql write-db sql)
                                    (cond
                                      ((or result (and (listp result-code)
                                                       (not (null result-code))))
                                       (%stream-response req +http-ok+ result-code result))
                                      (result-code (if (eq :get (lack.request:request-method req))
                                                       (%empty-response +http-bad-request+)
                                                       (bt:with-lock-held (write-lock)
                                                         (if (eq original-md (endb/sql/expr:db-meta-data db))
                                                             (progn
                                                               (setf db (endb/sql:commit-write-tx db write-db))
                                                               (%stream-response req +http-created+ '("result") (list (list result-code))))
                                                             (%empty-response +http-conflict+)))))
                                      (t (%empty-response +http-conflict+))))
                                  (%empty-response +http-not-acceptable+))
                              (%empty-response +http-bad-request+))))
                    (%empty-response +http-method-not-allowed+ '(:allow "GET, POST")))
                (%empty-response +http-not-found+)))
        (endb/lib/parser:sql-parse-error (e)
          (%error-response +http-bad-request+ e))
        (endb/sql/expr:sql-runtime-error (e)
          (%error-response +http-bad-request+ e))
        (error (e)
          (log:error e)
          (%error-response +http-internal-server-error+ e))))))
