(defpackage :endb/http
  (:use :cl)
  (:export #:make-api-handler)
  (:import-from :bordeaux-threads)
  (:import-from :lack.request)
  (:import-from :cl-ppcre)
  (:import-from :com.inuoe.jzon)
  (:import-from :trivial-utf-8)
  (:import-from :endb/sql))
(in-package :endb/http)

(defconstant +http-ok+ 200)
(defconstant +http-created+ 201)
(defconstant +http-bad-request+ 400)
(defconstant +http-not-found+ 404)
(defconstant +http-method-not-allowed+ 405)
(defconstant +http-not-acceptable+ 406)
(defconstant +http-conflict+ 409)
(defconstant +http-unsupported-media-type+ 415)
(defconstant +http-internal-server-error+ 500)

(defparameter *crlf* (coerce '(#\return #\linefeed) 'string))
(defparameter *request-media-types* '("application/sql" "application/x-www-form-urlencoded"))
(defparameter *response-media-types* '("application/json" "application/x-ndjson" "text/csv"))

(defun %format-csv (x)
  (cl-ppcre:regex-replace-all "\\\\\"" (com.inuoe.jzon:stringify x) "\"\""))

(defun %empty-response (status &optional headers)
  (list status (append headers '(:content-type "text/plain" :content-length 0)) '("")))

(defun %stream-response (req status column-names rows)
  (lambda (responder)
    (let ((writer (funcall responder (list status (list :content-type
                                                        (cond
                                                          ((lack.request:request-accepts-p req "application/json")
                                                           "application/json")
                                                          ((lack.request:request-accepts-p req "application/x-ndjson")
                                                           "application/x-ndjson")
                                                          ((lack.request:request-accepts-p req "text/csv")
                                                           "text/csv"))))) ))
      (cond
        ((lack.request:request-accepts-p req "application/json")
         (progn (funcall writer "[")
                (loop for row in rows
                      do (funcall writer (com.inuoe.jzon:stringify row))
                      finally (funcall writer "]" :close t))))
        ((lack.request:request-accepts-p req "application/x-ndjson")
         (loop for row in rows
               do (loop for column in row
                        for column-name in column-names
                        do (funcall writer (with-output-to-string (out)
                                             (com.inuoe.jzon:with-writer (writer :stream out)
                                               (com.inuoe.jzon:with-object writer
                                                 (com.inuoe.jzon:write-key writer column-name)
                                                 (com.inuoe.jzon:write-value writer column)))
                                             (write-char #\NewLine out))))
               finally (funcall writer nil :close t)))
        ((lack.request:request-accepts-p req "text/csv")
         (loop for row in (cons column-names rows)
               do (funcall writer (format nil "~{~A~^,~}~A" (mapcar #'%format-csv row) *crlf*))
               finally (funcall writer nil :close t)))))))

(defun make-api-handler (db)
  (let ((write-lock (bt:make-lock)))
    (lambda (env)
      (let ((req (lack.request:make-request env)))
        (if (equal "/sql" (lack.request:request-path-info req))
            (if (member (lack.request:request-method req) '(:get :post))
                (if (and (eq :post (lack.request:request-method req))
                         (not (member (lack.request:request-content-type req) *request-media-types* :test 'equal)))
                    (list +http-unsupported-media-type+ nil nil)
                    (let* ((write-db (endb/sql:begin-write-tx db))
                           (original-md (endb/sql/expr:db-meta-data write-db))
                           (sql (if (and (eq :post (lack.request:request-method req))
                                         (equal "application/sql" (lack.request:request-content-type req)))
                                    (trivial-utf-8:utf-8-bytes-to-string (lack.request:request-content req))
                                    (cdr (assoc "q" (lack.request:request-parameters req) :test 'equal)))))
                      (if sql
                          (if (some (lambda (media-type)
                                      (lack.request:request-accepts-p req media-type))
                                    *response-media-types*)
                              (multiple-value-bind (result result-code)
                                  (endb/sql:execute-sql write-db sql)
                                (cond
                                  ((or result (and (listp result-code)
                                                   (not (null result-code))))
                                   (%stream-response req +http-ok+ result-code result))
                                  (result-code (if (eq :get (lack.request:request-method req))
                                                   (%empty-response +http-bad-request+)
                                                   (bt:with-lock-held (write-lock)
                                                     (if (eq original-md (endb/sql/expr:db-meta-data db))
                                                         (progn
                                                           (setf db (endb/sql:commit-write-tx db write-db))
                                                           (%stream-response req +http-created+ '("result") (list (list result-code))))
                                                         (%empty-response +http-conflict+)))))
                                  (t (%empty-response +http-internal-server-error+))))
                              (%empty-response +http-not-acceptable+))
                          (%empty-response +http-bad-request+))))
                (%empty-response +http-method-not-allowed+ '(:allow "GET, POST")))
            (%empty-response +http-not-found+))))))
