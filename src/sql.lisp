(defpackage :endb/sql
  (:use :cl)
  (:export #:*query-timing* #:*lib-parser* #:make-db #:begin-write-tx #:commit-write-tx #:execute-sql)
  (:import-from :alexandria)
  (:import-from :endb/sql/expr)
  (:import-from :endb/sql/parser)
  (:import-from :endb/sql/compiler)
  (:import-from :endb/lib/arrow)
  (:import-from :endb/lib/parser)
  (:import-from :endb/storage/buffer-pool)
  (:import-from :endb/storage/meta-data)
  (:import-from :endb/storage/object-store)
  (:import-from :endb/storage/wal)
  (:import-from :fset))
(in-package :endb/sql)

(defvar *query-timing* nil)
(defvar *lib-parser* nil)

(defun make-db (&key (read-wal (endb/storage/wal:make-memory-wal)) (write-wal read-wal) (object-store (endb/storage/object-store:make-memory-object-store)))
  (let* ((buffer-pool (endb/storage/buffer-pool:make-buffer-pool :object-store object-store))
         (md (fset:empty-map)))
    (loop for (buffer . name) = (multiple-value-bind (buffer name)
                                    (endb/storage/wal:wal-read-next-entry read-wal :skip-if (lambda (x)
                                                                                              (not (alexandria:starts-with-subseq "_log/" x))))
                                  (cons buffer name))
          when buffer
            do (setf md (endb/storage/meta-data:meta-data-merge-patch md (endb/storage/meta-data:json->meta-data buffer)))
          while name)
    (endb/sql/expr:make-db :wal write-wal :object-store object-store :buffer-pool buffer-pool :meta-data md)))

(defun begin-write-tx (db)
  (let* ((bp (endb/storage/buffer-pool:make-writeable-buffer-pool :parent-pool (endb/sql/expr:db-buffer-pool db)))
         (tx-db (endb/sql/expr:copy-db db)))
    (setf (endb/sql/expr:db-buffer-pool tx-db) bp)
    tx-db))

(defun %log-filename (tx-id)
  (format nil "_log/~16,'0X.json" tx-id))

(defun %write-new-buffers (tx-db)
  (let ((os (endb/sql/expr:db-object-store tx-db))
        (bp (endb/sql/expr:db-buffer-pool tx-db))
        (wal (endb/sql/expr:db-wal tx-db)))
    (loop for k being the hash-key
            using (hash-value v)
              of (endb/storage/buffer-pool:writeable-buffer-pool-pool bp)
          for buffer = (endb/lib/arrow:write-arrow-arrays-to-ipc-buffer v)
          do (endb/storage/object-store:object-store-put os k buffer)
             (endb/storage/wal:wal-append-entry wal k buffer))))

(defun commit-write-tx (db tx-db &key (fsyncp t))
  (let* ((current-md (endb/sql/expr:db-meta-data db))
         (tx-md (endb/sql/expr:db-meta-data tx-db))
         (tx-id (1+ (or (fset:lookup tx-md "_last_tx") 0)))
         (tx-md (fset:with tx-md "_last_tx" tx-id))
         (md-diff (endb/storage/meta-data:meta-data-diff current-md tx-md))
         (wal (endb/sql/expr:db-wal tx-db)))
    (%write-new-buffers tx-db)
    (endb/storage/wal:wal-append-entry wal (%log-filename tx-id) (endb/storage/meta-data:meta-data->json md-diff))
    (when fsyncp
      (endb/storage/wal:wal-fsync wal))
    (let ((new-db (endb/sql/expr:copy-db db))
          (new-md (endb/storage/meta-data:meta-data-merge-patch current-md md-diff)))
      (setf (endb/sql/expr:db-meta-data new-db) new-md)
      new-db)))

(defun %execute-sql (db sql)
  (let* ((ast (if *lib-parser*
                  (endb/lib/parser:parse-sql sql)
                  (endb/sql/parser:parse-sql sql)))
         (ctx (fset:map (:db db)))
         (sql-fn (endb/sql/compiler:compile-sql ctx ast))
         (*print-length* 16))
    (funcall sql-fn db)))

(defun execute-sql (db sql)
  (if *query-timing*
      (time (%execute-sql db sql))
      (%execute-sql db sql)))
